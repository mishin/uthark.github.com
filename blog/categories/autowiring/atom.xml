<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: autowiring | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/autowiring/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-29T23:39:52-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Пишем @Enable*-аннотацию для Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/29/spring-enable-annotation/"/>
    <updated>2013-06-29T23:15:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/29/spring-enable-annotation</id>
    <content type="html"><![CDATA[<p>Начиная с версии 3.1 Spring поддерживает декларативное включение необходимой функциональности через, так называемые, <code>@Enable*</code> аннотации. Пример таких аннотаций:
<a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/web/servlet/config/annotation/EnableWebMvc.html"><code>org.springframework.web.servlet.config.annotation.EnableWebMvc</code></a>, <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/cache/annotation/EnableCaching.html"><code>org.springframework.cache.annotation.EnableCaching</code></a>, <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/scheduling/annotation/EnableAsync.html"><code>org.springframework.scheduling.annotation.EnableAsync</code></a> и другие.</p>

<p>В продолжение темы <a href="/blog/2013/06/28/jaxrs-spring-autowiring/">прошлого поста</a>, я хочу показать, как можно добавить собственную <code>@Enable</code> аннотацию.</p>

<p>Для автоматического создания клиента для REST-ресурса нам необходима следующая информация:</p>

<ol>
<li>Пакет, в котором искать интерфейсы, проаннотированные аннотацией <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html"><code>@Path()</code></a></li>
<li>Базовый адрес REST-приложения.</li>
</ol>


<p>Для того, чтобы передать эту информацию, мы создадим два атрибута в аннотации: <code>scanPackage()</code> и <code>endpoint()</code></p>

<p>Кроме того, для обработки аннотации необходимо указать обработчик. Это можно сделать передав подкласс <a href="http://static.springsource.org/spring-framework/docs/3.2.x/javadoc-api/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.html"><code>org.springframework.context.annotation.ImportBeanDefinitionRegistrar</code></a> через аннотацию <a href="http://static.springsource.org/spring-framework/docs/3.2.x/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a></p>

<p>Пишем аннотацию:</p>

<p>{% codeblock lang:java %}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JaxRsRestClientRegistrar.class)
public @interface EnableJaxRsRestClient {</p>

<pre><code>String scanPackage();

String endpoint();
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>Теперь осталось написать реализацию интерфейса <code>org.springframework.context.annotation.ImportBeanDefinitionRegistrar</code>. Так как у нас уже есть написанный ранее <a href="http://static.springsource.org/spring-framework/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html">BeanFactoryPostProcessor</a> в виде <code>RestClientPostProcessor</code>, реализация интерфейса будет простой &ndash; мы создадим описание бина для Spring и зарегистрируем его в реестре бинов.</p>

<p>{% codeblock lang:java %}
public class JaxRsRestClientRegistrar implements ImportBeanDefinitionRegistrar {</p>

<pre><code>protected static final String PROPERTY_ENDPOINT = "endpoint";

protected static final String PROPERTY_SCAN_PACKAGE = "basePackage";

@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    EnableJaxRsRestClient annotation =
            (EnableJaxRsRestClient) ((StandardClassMetadata) importingClassMetadata).getIntrospectedClass()
                    .getAnnotation(EnableJaxRsRestClient.class);
    String scanPackage = annotation.scanPackage();
    String endpoint = annotation.endpoint();

    GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
    beanDefinition.setAbstract(false);
    beanDefinition.setBeanClass(RestClientPostProcessor.class);
    MutablePropertyValues propertyValues = new MutablePropertyValues();
    propertyValues.add(PROPERTY_ENDPOINT, endpoint);
    propertyValues.add(PROPERTY_SCAN_PACKAGE, scanPackage);
    beanDefinition.setPropertyValues(propertyValues);

    registry.registerBeanDefinition(ClassUtils.getShortName(getClass()), beanDefinition);
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>Теперь мы можем использовать аннотацию:</p>

<p>{% codeblock lang:java %}
@Configuration
@EnableJaxRsRestClient(scanPackage = &ldquo;<base package>&rdquo;, endpoint = &ldquo;${remote.rest.endpoint}&rdquo;)
class TestAutowiringConfiguration {</p>

<pre><code>@Bean
public static PropertyPlaceholderConfigurer configurer() {
    PropertyPlaceholderConfigurer pph = new PropertyPlaceholderConfigurer();
    pph.setLocation(new ClassPathResource("application.properties"));
    return pph;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Обратите внимание, что endpoint можно передавать с использованием подстановочных свойств.</p>

<p>На этом всё, если есть вопросы &ndash; <a href="https://plus.google.com/112372998073079463630/posts">спрашивайте в Google+</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[@Autowired JAX-RS Client API]]></title>
    <link href="http://uthark.github.com/blog/2013/06/28/jaxrs-spring-autowiring/"/>
    <updated>2013-06-28T19:05:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/28/jaxrs-spring-autowiring</id>
    <content type="html"><![CDATA[<p>Продолжая разговор о <a href="http://www.jcp.org/en/jsr/detail?id=339">JAX RS</a> <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/package-summary.html">Client API</a> &ndash; предположим, что мы уже <a href="/blog/2013/06/28/jaxrs/">используем JAX-RS клиент</a></p>

<p>У нас есть класс, который умеет создавать прокси для любого REST-интерфейса в проекте. Теперь мы хотим сделать так, чтобы эти интерфейсы можно было автоматически создавать в контексте Spring и связывать с другими бинами.</p>

<p>Первое решение, которое приходит в лоб &ndash; объявить бин в конфигурации для каждого интерфейса:</p>

<p>{% codeblock lang:java %}
@Configuration
public class SpringConfiguration {</p>

<pre><code>@Bean
public UserRest userRest(){
    List&lt;?&gt; providers = Arrays.asList(new JsonMessageHandler(new ObjectMapper()));
    return JAXRSClientFactory.create("http://localhost:8080", UserRest.class, providers);
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>Написав объявление нескольких таких бинов можно задуматься &ndash; &ldquo;Есть ли способ проще?&rdquo;.</p>

<p>Есть, и я вам сейчас его покажу.</p>

<p>Для того, чтобы добавлять собственные бины в Spring контекст, мы воспользуемся возможностью расширения Spring контекста с использованием <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a>.
Метод <code>postProcessBeanFactory</code> данного класса позволяет выполнить дополнительную обработку фабрики бинов Spring, например, удалить, добавить, переопределить бин.
Это именно то, что нам нужно &ndash; автоматически добавить новые бины в фабрику.</p>

<p>Итак, что нам нужно сделать:</p>

<ol>
<li>Найти все доступные REST интерфейсы в текущем classpath.</li>
<li>Для каждого из них создать прокси с использованием <code>JAXRSClientFactory</code> .</li>
<li>Зарегистрировать каждый прокси в фабрике бинов для дальнейшего использования (например, для @Autowired).</li>
</ol>


<p>По спецификации JAX-RS, чтобы класс распознавался как REST-ресурс, у него должна быть аннотация <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html"><code>@Path()</code></a>.</p>

<p>Для поиска всех возможных классов/интерфейсов воспользуемся классом <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/context/annotation/ClassPathScanningCandidateComponentProvider.html"><code>ClassPathScanningCandidateComponentProvider</code></a>, который умеет сканировать классы в выбранном пакете и применять фильтры, чтобы собрать только нужные. Также нам нужно учесть, что по умолчанию <code>ClassPathScanningCandidateComponentProvider</code> пытается определить, может ли найденный класс быть и бином (например, проверяет, что это не абстрактный класс и не интерфейс), поэтому нам нужно написать подкласс, который позволит нам работать с интерфейсами.</p>

<p>Пишем класс:
{% codeblock lang:java %}
public class RestClientPostProcessor implements BeanFactoryPostProcessor {</p>

<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(RestClientPostProcessor.class);

protected String endpoint = "http://localhost:8080";

private Class&lt;? extends Annotation&gt; requiredAnnotation = Path.class;

private String basePackage = "&lt;base package&gt;";

private ObjectMapper objectMapper;

// getters/setters omitted.

protected Object createBean(Class&lt;?&gt; clazz) {
    List&lt;?&gt; providers = Arrays.asList(new JsonMessageHandler(objectMapper));
    return JAXRSClientFactory.create(endpoint, clazz, providers);
}

@Override 
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    ClassPathScanningCandidateComponentProvider provider = new ClasspathScanner();
    provider.addIncludeFilter(new AnnotationTypeFilter(requiredAnnotation));
    Set&lt;BeanDefinition&gt; components = provider.findCandidateComponents(basePackage);

    for (BeanDefinition component : components) {
        createAndRegisterBean(beanFactory, component);

    }
}

protected void createAndRegisterBean(ConfigurableListableBeanFactory beanFactory, BeanDefinition component) {
    try {
        String beanClassName = component.getBeanClassName();
        Class&lt;?&gt; clazz = Class.forName(beanClassName);

        Object o = createBean(clazz);

        beanFactory.registerResolvableDependency(clazz, o);
    } catch (ClassNotFoundException e) {
        LOGGER.warn("Unable to find class: {}", component.getBeanClassName(), e);
    }
}

private static class ClasspathScanner extends ClassPathScanningCandidateComponentProvider {

    public ClasspathScanner() {
        super(false);
    }

    @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        // override this method, because our classes are interfaces, by default interfaces are
        // not allowed.
        return beanDefinition.getMetadata().isIndependent();
    }
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>Теперь этот процессор необходимо зарегистрировать в контексте Spring:
{% codeblock lang:java %}
@Configuration
class TestAutowiringConfiguration {</p>

<pre><code>@Bean
public static RestClientPostProcessor autowiringRestApiProcessor() {
    return new RestClientPostProcessor();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>И теперь можно использовать <code>UserRest</code> как обычный бин:
{% codeblock lang:java %}</p>

<pre><code>@Autowired
private UserShowRest userShowRest;
</code></pre>

<p>{% endcodeblock %}</p>

<p>Если есть вопросы &ndash; <a href="https://plus.google.com/112372998073079463630/posts">спрашивайте в Google+</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[@Autowiring EJBs with Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/autowiring-factorybean/"/>
    <updated>2013-06-19T20:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/autowiring-factorybean</id>
    <content type="html"><![CDATA[<p>Предположим, что у нас есть проект на Spring, в котором необходимо использовать внешние EJB. Для получения бинов необходимо создавать <a href="http://docs.oracle.com/javase/6/docs/api/javax/naming/InitialContext.html">InitialContext</a> и делать <code>lookup()</code> нужных ejb. Но эту задачу можно автоматизировать и пользоваться <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">@Autowired</a>, то есть код будет выглядеть вот так:</p>

<p>{% codeblock lang:java %}
@Service
public class UserService {</p>

<p>  @Autowired
  private UserRemoteBean userRemoteBean;</p>

<p>}
{% endcodeblock %}</p>

<p>Для этого в Spring существует <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/htmlsingle/#beans-factory-extension-factorybean">FactoryBean</a> &ndash; класс, который знает, как создавать бины нужного типа. Собственно, нам необходимо написать такой класс (код на <a href="http://www.scala-lang.org/">Scala</a>):</p>

<p>{% codeblock lang:scala %}
@Component
class UserRemoteBeanFactoryBean extends FactoryBean[UserRemoteBean] {</p>

<p>  def ACCESS_BEAN_REMOTE_NAME: String = &ldquo;our ejb name.&rdquo;</p>

<p>  private val log: Logger = LoggerFactory.getLogger(getObjectType)</p>

<p>  var ctx: Context = null</p>

<p>  def getObject: UserRemoteBean = {</p>

<pre><code>log.debug("Requesting new instance of {}", getObjectType)

try {
  ctx.lookup(ACCESS_BEAN_REMOTE_NAME).asInstanceOf[UserRemoteBean]
}
catch {
  case e: NamingException =&gt; {
    log.error("Unable to get ejb: {}", Array[AnyRef](e.getMessage, e): _*)
    throw new RuntimeException("Unable to get UserRemoteBean bean " + e.getMessage, e)
  }

}
</code></pre>

<p>  }</p>

<p>  @PostConstruct
  protected def init() {</p>

<pre><code>val jndiProperties: Hashtable[String, Object] = new Hashtable[String, Object]
jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming")
jndiProperties.put("jboss.naming.client.ejb.context", new java.lang.Boolean(true))
try
  ctx = new InitialContext(jndiProperties)
catch {
  case e: NamingException =&gt; log.error("Unable to create JNDI Context: {}", Array[AnyRef](e.getMessage, e): _*)
}
</code></pre>

<p>  }</p>

<p>  def isSingleton: Boolean = {</p>

<pre><code>false
</code></pre>

<p>  }</p>

<p>  def getObjectType: Class[_] = classOf[UserRemoteBean]
}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
