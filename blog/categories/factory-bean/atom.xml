<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: factory bean | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/factory-bean/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-29T23:39:52-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[@Autowiring EJBs with Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/autowiring-factorybean/"/>
    <updated>2013-06-19T20:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/autowiring-factorybean</id>
    <content type="html"><![CDATA[<p>Предположим, что у нас есть проект на Spring, в котором необходимо использовать внешние EJB. Для получения бинов необходимо создавать <a href="http://docs.oracle.com/javase/6/docs/api/javax/naming/InitialContext.html">InitialContext</a> и делать <code>lookup()</code> нужных ejb. Но эту задачу можно автоматизировать и пользоваться <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">@Autowired</a>, то есть код будет выглядеть вот так:</p>

<p>{% codeblock lang:java %}
@Service
public class UserService {</p>

<p>  @Autowired
  private UserRemoteBean userRemoteBean;</p>

<p>}
{% endcodeblock %}</p>

<p>Для этого в Spring существует <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/htmlsingle/#beans-factory-extension-factorybean">FactoryBean</a> &ndash; класс, который знает, как создавать бины нужного типа. Собственно, нам необходимо написать такой класс (код на <a href="http://www.scala-lang.org/">Scala</a>):</p>

<p>{% codeblock lang:scala %}
@Component
class UserRemoteBeanFactoryBean extends FactoryBean[UserRemoteBean] {</p>

<p>  def ACCESS_BEAN_REMOTE_NAME: String = &ldquo;our ejb name.&rdquo;</p>

<p>  private val log: Logger = LoggerFactory.getLogger(getObjectType)</p>

<p>  var ctx: Context = null</p>

<p>  def getObject: UserRemoteBean = {</p>

<pre><code>log.debug("Requesting new instance of {}", getObjectType)

try {
  ctx.lookup(ACCESS_BEAN_REMOTE_NAME).asInstanceOf[UserRemoteBean]
}
catch {
  case e: NamingException =&gt; {
    log.error("Unable to get ejb: {}", Array[AnyRef](e.getMessage, e): _*)
    throw new RuntimeException("Unable to get UserRemoteBean bean " + e.getMessage, e)
  }

}
</code></pre>

<p>  }</p>

<p>  @PostConstruct
  protected def init() {</p>

<pre><code>val jndiProperties: Hashtable[String, Object] = new Hashtable[String, Object]
jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming")
jndiProperties.put("jboss.naming.client.ejb.context", new java.lang.Boolean(true))
try
  ctx = new InitialContext(jndiProperties)
catch {
  case e: NamingException =&gt; log.error("Unable to create JNDI Context: {}", Array[AnyRef](e.getMessage, e): _*)
}
</code></pre>

<p>  }</p>

<p>  def isSingleton: Boolean = {</p>

<pre><code>false
</code></pre>

<p>  }</p>

<p>  def getObjectType: Class[_] = classOf[UserRemoteBean]
}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
