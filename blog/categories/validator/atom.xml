<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: validator | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/validator/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-19T01:13:25-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Пишем собственный валидатор для Bean Validation API]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/custom-bean-validator/"/>
    <updated>2013-06-19T08:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/custom-bean-validator</id>
    <content type="html"><![CDATA[<p><a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a> предоставляет удобный API для проверки валидности объектов, а также входных параметров. Очевидно, что стандартных валидаторов в какой-то момент может быть недостаточно, поэтому необходимо писать собственный.</p>

<p>Хочу показать на примере, как легко это делается.</p>

<h2>Создаём аннотацию</h2>

<p>{% codeblock lang:java %}
@Target({FIELD, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {MongoQueryValidator.class})
public @interface MongoQuery {</p>

<pre><code>String message() default "Invalid mongo query";

Class&lt;?&gt;[] groups() default {};

Class&lt;? extends Payload&gt;[] payload() default {};
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Обратите внимание на аннотацию <a href="http://docs.oracle.com/javaee/7/api/javax/validation/Constraint.html">@Constraint</a> &ndash; она описывает, какой класс будет проводить реальную валидацию. Атрибуты <code>groups()</code> и <code>payload()</code> являются обязательными.</p>

<h2>Пишем валидатор</h2>

<p>{% codeblock lang:java %}
public class MongoQueryValidator implements ConstraintValidator&lt;MongoQuery, CharSequence> {</p>

<pre><code>@Override
public void initialize(MongoQuery constraintAnnotation) {
}

@Override
public boolean isValid(CharSequence value, ConstraintValidatorContext context) {
    // ignore null and empty strings.
    if (null == value || value.length() == 0) {
        return true;
    }

    try {
        Query query = new BasicQuery(value.toString());
        return true;
    } catch (Exception e) {
        return false;
    }

}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>В данном случае, валидатор просто пытается создать Mongo Query из переданной строки, если это не удаётся, то считаем, что строка не является корректным запросом к Mongo и возвращаем <code>false</code>.</p>

<p>Если есть желание возвращать динамическое сообщение об ошибке, то это можно сделать следующим образом:</p>

<p>{% codeblock lang:java %}</p>

<pre><code>context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("&lt;Custom error message&gt;").addConstraintViolation();
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Использование</h2>

<p>На этом всё, теперь нам остаётся только добавить валидацию на нашу модель или входной параметр.</p>

<p>{% codeblock lang:java %}
public class Model {</p>

<pre><code>@MongoQuery
private String queryCriteria;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
