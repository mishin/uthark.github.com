<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: spring framework | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/spring-framework/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-29T23:39:52-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[@Autowiring EJBs with Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/autowiring-factorybean/"/>
    <updated>2013-06-19T20:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/autowiring-factorybean</id>
    <content type="html"><![CDATA[<p>Предположим, что у нас есть проект на Spring, в котором необходимо использовать внешние EJB. Для получения бинов необходимо создавать <a href="http://docs.oracle.com/javase/6/docs/api/javax/naming/InitialContext.html">InitialContext</a> и делать <code>lookup()</code> нужных ejb. Но эту задачу можно автоматизировать и пользоваться <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">@Autowired</a>, то есть код будет выглядеть вот так:</p>

<p>{% codeblock lang:java %}
@Service
public class UserService {</p>

<p>  @Autowired
  private UserRemoteBean userRemoteBean;</p>

<p>}
{% endcodeblock %}</p>

<p>Для этого в Spring существует <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/htmlsingle/#beans-factory-extension-factorybean">FactoryBean</a> &ndash; класс, который знает, как создавать бины нужного типа. Собственно, нам необходимо написать такой класс (код на <a href="http://www.scala-lang.org/">Scala</a>):</p>

<p>{% codeblock lang:scala %}
@Component
class UserRemoteBeanFactoryBean extends FactoryBean[UserRemoteBean] {</p>

<p>  def ACCESS_BEAN_REMOTE_NAME: String = &ldquo;our ejb name.&rdquo;</p>

<p>  private val log: Logger = LoggerFactory.getLogger(getObjectType)</p>

<p>  var ctx: Context = null</p>

<p>  def getObject: UserRemoteBean = {</p>

<pre><code>log.debug("Requesting new instance of {}", getObjectType)

try {
  ctx.lookup(ACCESS_BEAN_REMOTE_NAME).asInstanceOf[UserRemoteBean]
}
catch {
  case e: NamingException =&gt; {
    log.error("Unable to get ejb: {}", Array[AnyRef](e.getMessage, e): _*)
    throw new RuntimeException("Unable to get UserRemoteBean bean " + e.getMessage, e)
  }

}
</code></pre>

<p>  }</p>

<p>  @PostConstruct
  protected def init() {</p>

<pre><code>val jndiProperties: Hashtable[String, Object] = new Hashtable[String, Object]
jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming")
jndiProperties.put("jboss.naming.client.ejb.context", new java.lang.Boolean(true))
try
  ctx = new InitialContext(jndiProperties)
catch {
  case e: NamingException =&gt; log.error("Unable to create JNDI Context: {}", Array[AnyRef](e.getMessage, e): _*)
}
</code></pre>

<p>  }</p>

<p>  def isSingleton: Boolean = {</p>

<pre><code>false
</code></pre>

<p>  }</p>

<p>  def getObjectType: Class[_] = classOf[UserRemoteBean]
}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Использование memcached в качестве backend для Spring Caching Abstraction]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/spring-caching/"/>
    <updated>2013-06-19T19:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/spring-caching</id>
    <content type="html"><![CDATA[<p>В <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html">Spring 3.1</a> появился замечательный модуль &ndash; <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/cache.html">Spring Cache</a>, который является абстракцией над кэшированием, что позволяет декларативно реализовывать кэширование в приложении.</p>

<p>Я не буду вдаваться в подробности работы, их можно прочитать в документации, но опишу, каким образом можно настроить <a href="http://memcached.org/">memcached</a> в качестве бэкэнда для работы.</p>

<h2>Подключение зависимостей</h2>

<p>{% codeblock lang:xml %}
<dependency></p>

<pre><code>&lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt;
&lt;artifactId&gt;spymemcached-provider&lt;/artifactId&gt;
&lt;version&gt;3.1.0&lt;/version&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt;
&lt;artifactId&gt;spring-cache&lt;/artifactId&gt;
&lt;version&gt;3.1.0&lt;/version&gt;
</code></pre>

<p></dependency>
{% endcodeblock %}</p>

<p><code>spymemcached-provider</code> &ndash; это библиотечка для работы с <code>memcached</code> из Java, а <code>spring-cache</code> &ndash; модуль интеграции со Spring.</p>

<h2>Включение кэширования</h2>

<p>{% codeblock lang:java %}</p>

<p>@Configuration(&ldquo;serviceConfiguration&rdquo;)
@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)
@Import(CacheConfiguration.class)
public class ServiceConfiguration {
  // bean declarations goes here.
}
{% endcodeblock %}</p>

<p>Аннотация <code>@EnableCaching</code> включает кэширование. Конфигурацию бинов для кэширования мы выносим в отдельный класс, <code>CacheConfiguration</code>, чтобы не смешивать бины, отвечающие за кэширование с бинами, отвечающими за бизнес-логику.</p>

<p>Объявляем необходимые для работы бины:</p>

<p>{% codeblock lang:java %}
@Configuration
public class CacheConfiguration {</p>

<pre><code>@Value("${memcached.url}")
private String memcachedUrl;

@Bean
public CacheManager cacheManager() throws Exception {
    SSMCacheManager result = new SSMCacheManager();
    result.setCaches(Arrays.asList(
            new SSMCache(defaultCacheFactory().getObject(), 45)
    ));
    return result;
}

@Bean
public CacheFactory defaultCacheFactory() {
    CacheFactory factory = new CacheFactory();
    factory.setCacheName("defaultCache");
    factory.setAddressProvider(addressProvider());
    factory.setCacheClientFactory(cacheClientFactory());
    factory.setConfiguration(cacheConfiguration());
    return factory;
}

@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public CacheClientFactory cacheClientFactory() {
    return new MemcacheClientFactoryImpl();
}

@Bean
public AddressProvider addressProvider() {
    return new DefaultAddressProvider(memcachedUrl);
}

@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public com.google.code.ssm.providers.CacheConfiguration cacheConfiguration() {
    com.google.code.ssm.providers.CacheConfiguration configuration =
            new com.google.code.ssm.providers.CacheConfiguration();
    configuration.setConsistentHashing(true);
    return configuration;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>Использование</h2>

<p>{% codeblock lang:java %}
@Cacheable(&ldquo;defaultCache&rdquo;)
public List<User> getUser(@NotNull String username) throws IOException {</p>

<pre><code>// ...
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Валидация входных параметров с использованием Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/validation/"/>
    <updated>2013-06-19T07:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/validation</id>
    <content type="html"><![CDATA[<p>Очень часто возникает задача проверки входных параметров в сервис на корректность с точки зрения бизнес логики.</p>

<p>Эту задачу можно решить в лоб, написав вручную код валидации в каждом из методов сервиса, например, вот так:</p>

<p>{% codeblock lang:java %}
  public User save(User user) {</p>

<pre><code>if(user == null) {
    throw new IllegalArgumentException("User is null");
}
// other checks
//...

// business logic starts here...
//...
return savedUser;
</code></pre>

<p>  }
{% endcodeblock %}</p>

<p>Очевидно, что если в каждом методе делать такие проверки, то код бизнес-логики загрязняется проверками, что ухудшает читаемость кода. Решить эту проблему можно следующим образом:</p>

<ol>
<li>Добавляем аннотации для валидации входных параметров.
{% codeblock lang:java %}
public @NotNull User save(@NotNull User user) {
 // business logic starts here&hellip;
 //&hellip;
 return savedUser;
}
{% endcodeblock %}</li>
</ol>


<p>Чтобы заставить этот код работать, мы будем использовать возможности Spring Validation.</p>

<ol>
<li>Spring предоставляет аннотацию <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/validation/annotation/Validated.html">@Validated</a>, которая в отличие от <a href="http://docs.oracle.com/javaee/7/api/javax/validation/Valid.html">@javax.validation.Valid</a> позволяет определять группу валидации.</li>
<li><p>Этой аннотацией необходимо проаннотировать бин, методы которого необходимо валидировать.
{% codeblock lang:java %}
 @Validated
 @Service
 public class UserService {
     public @NotNull User save(@NotNull User user) {
         // business logic starts here&hellip;
         //&hellip;
         return savedUser;
     }
 }
{% endcodeblock %}</p></li>
<li><p>Для реализации самой валидации нам необходим валидатор. В качестве реализации <a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a> можно использовать, например, <a href="http://www.hibernate.org/subprojects/validator.html">Hibernate Validator</a>. Для этого в <code>pom.xml</code> необходимо добавить требуемые зависимости:</p></li>
</ol>


<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.validation&lt;/groupId&gt;
    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.GA&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;4.3.1.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>Обращаю внимание, что текущей на данный момент является <a href="http://beanvalidation.org/1.1/spec">спецификация</a> <a href="http://jcp.org/en/jsr/detail?id=349">JSR-349 Bean Validation 1.1</a>, которая поддерживает валидацию методов из коробки, но текущая версия Spring 3.2 &ndash; не поддерживает новый API, поэтому необходимо использовать старую версию API, и, соответственно, реализацию. Релевантный баг в Spring <a href="https://jira.springsource.org/browse/SPR-8199">SPR-8199</a>, поддержка нового API ожидается в Spring Framework 4.0.</p>

<ol>
<li>Необходимо объявить необходимые бины в конфигурации Spring:</li>
</ol>


<p>{% codeblock lang:java %}</p>

<pre><code>@Bean
public LocalValidatorFactoryBean validatorFactory() {
    LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
    factoryBean.afterPropertiesSet();
    return factoryBean;
}

@Bean
public Validator validator() {
    return validatorFactory().getValidator();
}

@Bean
public MethodValidationPostProcessor methodValidationPostProcessor() {
    return new MethodValidationPostProcessor();
}
</code></pre>

<p>{% endcodeblock %}</p>

<ol>
<li>На этом всё. Как видно, декларативная валидация входных параметров реализуется очень просто.</li>
</ol>

]]></content>
  </entry>
  
</feed>
