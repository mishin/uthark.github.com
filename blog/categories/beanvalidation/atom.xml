<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: beanvalidation | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/beanvalidation/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-19T01:13:25-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Пишем собственный валидатор для Bean Validation API]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/custom-bean-validator/"/>
    <updated>2013-06-19T08:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/custom-bean-validator</id>
    <content type="html"><![CDATA[<p><a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a> предоставляет удобный API для проверки валидности объектов, а также входных параметров. Очевидно, что стандартных валидаторов в какой-то момент может быть недостаточно, поэтому необходимо писать собственный.</p>

<p>Хочу показать на примере, как легко это делается.</p>

<h2>Создаём аннотацию</h2>

<p>{% codeblock lang:java %}
@Target({FIELD, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {MongoQueryValidator.class})
public @interface MongoQuery {</p>

<pre><code>String message() default "Invalid mongo query";

Class&lt;?&gt;[] groups() default {};

Class&lt;? extends Payload&gt;[] payload() default {};
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Обратите внимание на аннотацию <a href="http://docs.oracle.com/javaee/7/api/javax/validation/Constraint.html">@Constraint</a> &ndash; она описывает, какой класс будет проводить реальную валидацию. Атрибуты <code>groups()</code> и <code>payload()</code> являются обязательными.</p>

<h2>Пишем валидатор</h2>

<p>{% codeblock lang:java %}
public class MongoQueryValidator implements ConstraintValidator&lt;MongoQuery, CharSequence> {</p>

<pre><code>@Override
public void initialize(MongoQuery constraintAnnotation) {
}

@Override
public boolean isValid(CharSequence value, ConstraintValidatorContext context) {
    // ignore null and empty strings.
    if (null == value || value.length() == 0) {
        return true;
    }

    try {
        Query query = new BasicQuery(value.toString());
        return true;
    } catch (Exception e) {
        return false;
    }

}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>В данном случае, валидатор просто пытается создать Mongo Query из переданной строки, если это не удаётся, то считаем, что строка не является корректным запросом к Mongo и возвращаем <code>false</code>.</p>

<p>Если есть желание возвращать динамическое сообщение об ошибке, то это можно сделать следующим образом:</p>

<p>{% codeblock lang:java %}</p>

<pre><code>context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("&lt;Custom error message&gt;").addConstraintViolation();
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Использование</h2>

<p>На этом всё, теперь нам остаётся только добавить валидацию на нашу модель или входной параметр.</p>

<p>{% codeblock lang:java %}
public class Model {</p>

<pre><code>@MongoQuery
private String queryCriteria;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Валидация входных параметров с использованием Spring]]></title>
    <link href="http://uthark.github.com/blog/2013/06/19/validation/"/>
    <updated>2013-06-19T07:00:00-04:00</updated>
    <id>http://uthark.github.com/blog/2013/06/19/validation</id>
    <content type="html"><![CDATA[<p>Очень часто возникает задача проверки входных параметров в сервис на корректность с точки зрения бизнес логики.</p>

<p>Эту задачу можно решить в лоб, написав вручную код валидации в каждом из методов сервиса, например, вот так:</p>

<p>{% codeblock lang:java %}
  public User save(User user) {</p>

<pre><code>if(user == null) {
    throw new IllegalArgumentException("User is null");
}
// other checks
//...

// business logic starts here...
//...
return savedUser;
</code></pre>

<p>  }
{% endcodeblock %}</p>

<p>Очевидно, что если в каждом методе делать такие проверки, то код бизнес-логики загрязняется проверками, что ухудшает читаемость кода. Решить эту проблему можно следующим образом:</p>

<ol>
<li>Добавляем аннотации для валидации входных параметров.
{% codeblock lang:java %}
public @NotNull User save(@NotNull User user) {
 // business logic starts here&hellip;
 //&hellip;
 return savedUser;
}
{% endcodeblock %}</li>
</ol>


<p>Чтобы заставить этот код работать, мы будем использовать возможности Spring Validation.</p>

<ol>
<li>Spring предоставляет аннотацию <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/validation/annotation/Validated.html">@Validated</a>, которая в отличие от <a href="http://docs.oracle.com/javaee/7/api/javax/validation/Valid.html">@javax.validation.Valid</a> позволяет определять группу валидации.</li>
<li><p>Этой аннотацией необходимо проаннотировать бин, методы которого необходимо валидировать.
{% codeblock lang:java %}
 @Validated
 @Service
 public class UserService {
     public @NotNull User save(@NotNull User user) {
         // business logic starts here&hellip;
         //&hellip;
         return savedUser;
     }
 }
{% endcodeblock %}</p></li>
<li><p>Для реализации самой валидации нам необходим валидатор. В качестве реализации <a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a> можно использовать, например, <a href="http://www.hibernate.org/subprojects/validator.html">Hibernate Validator</a>. Для этого в <code>pom.xml</code> необходимо добавить требуемые зависимости:</p></li>
</ol>


<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.validation&lt;/groupId&gt;
    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.GA&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;4.3.1.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>Обращаю внимание, что текущей на данный момент является <a href="http://beanvalidation.org/1.1/spec">спецификация</a> <a href="http://jcp.org/en/jsr/detail?id=349">JSR-349 Bean Validation 1.1</a>, которая поддерживает валидацию методов из коробки, но текущая версия Spring 3.2 &ndash; не поддерживает новый API, поэтому необходимо использовать старую версию API, и, соответственно, реализацию. Релевантный баг в Spring <a href="https://jira.springsource.org/browse/SPR-8199">SPR-8199</a>, поддержка нового API ожидается в Spring Framework 4.0.</p>

<ol>
<li>Необходимо объявить необходимые бины в конфигурации Spring:</li>
</ol>


<p>{% codeblock lang:java %}</p>

<pre><code>@Bean
public LocalValidatorFactoryBean validatorFactory() {
    LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
    factoryBean.afterPropertiesSet();
    return factoryBean;
}

@Bean
public Validator validator() {
    return validatorFactory().getValidator();
}

@Bean
public MethodValidationPostProcessor methodValidationPostProcessor() {
    return new MethodValidationPostProcessor();
}
</code></pre>

<p>{% endcodeblock %}</p>

<ol>
<li>На этом всё. Как видно, декларативная валидация входных параметров реализуется очень просто.</li>
</ol>

]]></content>
  </entry>
  
</feed>
