<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jpa | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/jpa/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2012-07-19T16:22:13+07:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Собственная реализация методов в Spring Data JPA]]></title>
    <link href="http://uthark.github.com/blog/2012/04/28/spring-data-jpa_28/"/>
    <updated>2012-04-28T15:03:00+07:00</updated>
    <id>http://uthark.github.com/blog/2012/04/28/spring-data-jpa_28</id>
    <content type="html"><![CDATA[<div class='post'>
Очевидно, что мы не всегда можем воспользоваться автоматической генерацией кода, предоставляемой Spring Data JPA. Например, у нас слишком сложный запрос, или нам необходимо вызвать процедуру в базе данных, либо у нас сложная бизнес-логика.

Рассмотрим следующий пример - например, нам нужна функциональность уникального счётчика, который мы решили реализовать с помощью последовательности (sequence).

Сначала определим интерфейс, в котором опишем все методы, которые мы будем реализовывать самостоятельно. В нашем случае, это будет только один метод:

<pre class="brush:java">
public interface UserRepositoryCustom {
    /**
     * Returns next unique id.
     *
     * @return next unique id.
     */
    Integer getNextUniqueId();
}

</pre>

Затем обновим объявление репозитория, чтобы он унаследовал новый интерфейс <tt>UserRepositoryCustom</tt>

<pre class="brush:java">

public interface UserRepository extends JpaRepository&lt;User, Integer&gt;, UserRepositoryCustom {
   ...
}

</pre>

Теперь напишем реализацию метода:

<pre class="brush:java">
public class UserRepositoryImpl implements UserRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Integer getNextUniqueId() {

        // When using Hibernate via JPA native queries fails with mapping exception, so just use Hibernate directly:
        Session session = (Session) entityManager.getDelegate();
        SQLQuery nativeQuery = session.createSQLQuery("SELECT \"nextval\"('unique_id_seq') ");
        List&lt;BigInteger&gt; list = nativeQuery.list();
        if (list.isEmpty()) {
            throw new IncorrectResultSizeDataAccessException(1);
        }

        BigInteger result = list.get(0);

        return result.intValue();
    }
}
</pre>

И, наконец, укажем Spring Data JPA, чтобы в качестве класса для прокси использовался наш класс с реализацией собственных методов. Для этого нам нужна ещё одна секция <tt>repositories</tt> в конфигурационном файле:

<pre class="brush:xml">
    &lt;repositories base-package="[base.repository.package]"/&gt;

    &lt;repositories base-package="[base.repository.package]"&gt;
        &lt;repository id="userRepository" custom-impl-ref="userRepositoryImpl"/&gt;
    &lt;/repositories&gt;

    &lt;beans:bean id="userRepositoryImpl" class="...UserRepositoryImpl"/&gt;
</pre>

Вот и всё.</div>

]]></content>
  </entry>
  
</feed>
