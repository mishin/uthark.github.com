<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jpa | Блог о разработке ПО]]></title>
  <link href="http://uthark.github.com/blog/categories/jpa/atom.xml" rel="self"/>
  <link href="http://uthark.github.com/"/>
  <updated>2013-06-19T01:13:25-04:00</updated>
  <id>http://uthark.github.com/</id>
  <author>
    <name><![CDATA[Oleg Atamanenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Собственная реализация методов в Spring Data JPA]]></title>
    <link href="http://uthark.github.com/blog/2012/04/28/spring-data-jpa_28/"/>
    <updated>2012-04-28T04:03:00-04:00</updated>
    <id>http://uthark.github.com/blog/2012/04/28/spring-data-jpa_28</id>
    <content type="html"><![CDATA[<p>Очевидно, что мы не всегда можем воспользоваться автоматической генерацией кода, предоставляемой <a href="http://www.springsource.org/spring-data/jpa">Spring Data JPA</a>. Например, у нас слишком сложный запрос, или нам необходимо вызвать процедуру в базе данных, либо у нас сложная бизнес-логика.</p>

<p>Рассмотрим следующий пример &ndash; например, нам нужна функциональность уникального счётчика, который мы решили реализовать с помощью последовательности (sequence).</p>

<p>Сначала определим интерфейс, в котором опишем все методы, которые мы будем реализовывать самостоятельно. В нашем случае, это будет только один метод:</p>

<p>{% codeblock lang:java %}
public interface UserRepositoryCustom {</p>

<pre><code>/**
 * Returns next unique id.
 *
 * @return next unique id.
 */
Integer getNextUniqueId();
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>Затем обновим объявление репозитория, чтобы он унаследовал новый интерфейс <tt>UserRepositoryCustom</tt></p>

<p>{% codeblock lang:java %}</p>

<p>public interface UserRepository extends JpaRepository&lt;User, Integer>, UserRepositoryCustom {
   &hellip;
}</p>

<p>{% endcodeblock %}</p>

<p>Теперь напишем реализацию метода:</p>

<p>{% codeblock lang:java %}
public class UserRepositoryImpl implements UserRepositoryCustom {</p>

<pre><code>@PersistenceContext
private EntityManager entityManager;

@Override
public Integer getNextUniqueId() {

    // When using Hibernate via JPA native queries fails with mapping exception, so just use Hibernate directly:
    Session session = (Session) entityManager.getDelegate();
    SQLQuery nativeQuery = session.createSQLQuery("SELECT \"nextval\"('unique_id_seq') ");
    List&lt;BigInteger&gt; list = nativeQuery.list();
    if (list.isEmpty()) {
        throw new IncorrectResultSizeDataAccessException(1);
    }

    BigInteger result = list.get(0);

    return result.intValue();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>И, наконец, укажем Spring Data JPA, чтобы в качестве класса для прокси использовался наш класс с реализацией собственных методов. Для этого нам нужна ещё одна секция <tt>repositories</tt> в конфигурационном файле:</p>

<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;repositories base-package="[base.repository.package]"/&gt;

&lt;repositories base-package="[base.repository.package]"&gt;
    &lt;repository id="userRepository" custom-impl-ref="userRepositoryImpl"/&gt;
&lt;/repositories&gt;

&lt;beans:bean id="userRepositoryImpl" class="...UserRepositoryImpl"/&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>Вот и всё.</p>
]]></content>
  </entry>
  
</feed>
